from aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== /start ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer("ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.", reply_markup=keyboard)

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer("ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.")

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer("ğŸ§¾ Available usernames:", reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer("âŒ Sorry, this username has already been sold.")
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = (
        f"ğŸ’¼ You selected <b>{username}</b>\n\n"
        f"Please send <b>30 TON</b> to the seller's wallet:\n"
        f"<code>{TON_WALLET}</code>\n\n"
        "After sending the payment, click <b>'I have paid'</b> to notify the seller."
    )
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswitfrom aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer(get_text(callback.from_user.id, "confirm_payment"))
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{buyer} confirmed payment for {username} at {time_now}.")

# ====== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ======
@router.callback_query(lambda c: c.data.startswith("cancel_"))
async def cancel_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("cancel_", "")
    await callback.message.answer(get_text(callback.from_user.id, "cancelled", username=username))

# ====== Ø£Ù…Ø± /add ======
@router.message(Command("add"))
async def add_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "add_usage"))
        return

    new_username = parts[1]
    if new_username in usernames:
        await message.answer(get_text(message.from_user.id, "username_exists"))
    else:
        usernames[new_username] = False
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_added", username=new_username))

# ====== Ø£Ù…Ø± /remove ======
@router.message(Command("remove"))
async def remove_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "remove_usage"))
        return

    target_username = parts[1]
    if target_username in usernames:
        del usernames[target_username]
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_removed", username=target_username))
    else:
        await message.answer(get_text(message.from_user.id, "username_not_found"))

# ====== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø§ÙˆØªØ± ======
dp.include_router(router)

# ====== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ======
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer("âœ… Payment confirmed. The seller has been notified.")
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{
from aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer(get_text(callback.from_user.id, "confirm_payment"))
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{buyer} confirmed payment for {username} at {time_now}.")

# ====== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ======
@router.callback_query(lambda c: c.data.startswith("cancel_"))
async def cancel_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("cancel_", "")
    await callback.message.answer(get_text(callback.from_user.id, "cancelled", username=username))

# ====== Ø£Ù…Ø± /add ======
@router.message(Command("add"))
async def add_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "add_usage"))
        return

    new_username = parts[1]
    if new_username in usernames:
        await message.answer(get_text(message.from_user.id, "username_exists"))
    else:
        usernames[new_username] = False
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_added", username=new_username))

# ====== Ø£Ù…Ø± /remove ======
@router.message(Command("remove"))
async def remove_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "remove_usage"))
        return

    target_username = parts[1]
    if target_username in usernames:
        del usernames[target_username]
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_removed", username=target_username))
    else:
        await message.answer(get_text(message.from_user.id, "username_not_found"))

# ====== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø§ÙˆØªØ± ======
dp.include_router(routefrom aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer(get_text(callback.from_user.id, "confirm_payment"))
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{buyer} confirmed payment for {username} at {time_now}.")

# ====== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ======
@router.callback_query(lambda c: c.data.startswith("cancel_"))
async def cancel_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("cancel_", "")
    await callback.message.answer(get_text(callback.from_user.id, "cancelled", username=username))

# ====== Ø£Ù…Ø± /add ======
@router.message(Command("add"))
async def add_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "add_usage"))
        return

    new_username = parts[1]
    if new_username in usernames:
        await message.answer(get_text(message.from_user.id, "username_exists"))
    else:
        usernames[new_username] = False
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_added", username=new_username))

# ====== Ø£Ù…Ø± /remove ======
@router.message(Command("remove"))
async def remove_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "remove_usage"))
        return

    target_username = parts[1]
    if target_username in usernames:
        del usernames[target_username]
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_removed", username=target_username))
    else:
        await message.answer(get_text(message.from_user.id, "username_not_found"))

# ====== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø§ÙˆØªØ± ======
dp.include_router(router)

# ====== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ======
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())from aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer(get_text(callback.from_user.id, "confirm_payment"))
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{buyer} confirmed payment for {username} at {time_now}.")

# ====== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ======
@router.callback_query(lambda c: c.data.startswith("cancel_"))
async def cancel_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("cancel_", "")
    await callback.message.answer(get_text(callback.from_user.id, "cancelled", username=username))

# ====== Ø£Ù…Ø± /add ======
@router.message(Command("add"))
async def add_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "add_usage"))
        return

    new_username = parts[1]
    if new_username in usernames:
        await message.answer(get_text(message.from_user.id, "username_exists"))
    else:
        usernames[new_username] = False
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_added", username=new_username))

# ====== Ø£Ù…Ø± /remove ======
@router.message(Command("remove"))
async def remove_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "remove_usage"))
        return

    target_username = parts[1]
    if target_username in usernames:
        del usernames[target_username]
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_removed", username=target_username))
    else:
        await message.answer(get_text(message.from_user.id, "username_not_found"))

# ====== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø§ÙˆØªØ± ======
dp.include_router(router)

# ====== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ======
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())from aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answfrom aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer(get_text(callback.from_user.id, "confirm_payment"))
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{buyer} confirmed payment for {username} at {time_now}.")

# ====== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ======
@router.callback_query(lambda c: c.data.startswith("cancel_"))
async def cancel_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("cancel_", "")
    await callback.message.answer(get_text(callback.from_user.id, "cancelled", username=username))

# ====== Ø£Ù…Ø± /add ======
@router.message(Command("add"))
async def add_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "add_usage"))
        return

    new_username = parts[1]
    if new_username in usernames:
        await message.answer(get_text(message.from_user.id, "username_exists"))
    else:
        usernames[new_username] = False
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_added", username=new_username))

# ====== Ø£Ù…Ø± /remove ======
@router.message(Command("remove"))
async def remove_username_handler(message: types.Message):
    if message.from_user.id != OWNER_ID:
        return

    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].startswith("@"):
        await message.answer(get_text(message.from_user.id, "remove_usage"))
        return

    target_username = parts[1]
    if target_username in usernames:
        del usernames[target_username]
        save_usernames()
        await message.answer(get_text(message.from_user.id, "username_removed", username=target_username))
    else:
        await message.answer(get_text(message.from_user.id, "username_not_found"))

# ====== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø§ÙˆØªØ± ======
dp.include_router(router)

# ====== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ======
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())from aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("buy_", "")
    if usernames.get(username):
        await callback.message.answer(get_text(callback.from_user.id, "already_sold"))
        return

    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… I have paid", callback_data=f"confirm_{username}")],
        [InlineKeyboardButton(text="âŒ Cancel", callback_data=f"cancel_{username}")]
    ])

    text = get_text(callback.from_user.id, "select_username", username=username, wallet=TON_WALLET)
    await callback.message.answer(text, reply_markup=confirm_keyboard)

# ====== ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ======
@router.callback_query(lambda c: c.data.startswith("confirm_"))
async def confirm_payment(callback: CallbackQuery):
    await callback.answer()
    username = callback.data.replace("confirm_", "")

    if usernames.get(username):
        await callback.message.answer("âš ï¸ This username was already marked as sold.")
        return

    usernames[username] = True
    save_usernames()

    buyer = callback.from_user.username or f"ID:{callback.from_user.id}"
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sales_log.append({
        "username": username,
        "buyer": buyer,
        "time": time_now
    })
    save_sales_log()

    await callback.message.answer(get_text(callback.from_user.id, "confirm_payment"))
    await bot.send_message(OWNER_ID, f"ğŸ“¢ Buyer @{buyer} confirmed payment for {username} at {time_now}.")

# ====== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø· ======
@router.callback_query(lambda c: c.data.startswith("cancel_"))
async def cancel_handler(callback: CallbackQuery):
    await callback.answer()
    userom aiogram import Bot, Dispatcher, types, Router
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums.parse_mode import ParseMode
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
import asyncio
import json
import os
from datetime import datetime

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ======
TOKEN = "7709394502:AAEK2jdeiDFhMJkpwaw4AN9_TfcVCDydUpM"
OWNER_ID = 7928004645
TON_WALLET = "UQAvKW2nLoNs3Tj2P_ZB-yZSH8FzrBcPxlDT0UoZJJjj3h8l"

# ====== Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
USERNAMES_FILE = "usernames.json"
SALES_LOG_FILE = "sales_log.json"

default_usernames = {
    "@btcfx3": False,
    "@btcfx5": False,
    "@usdex1": False,
    "@ethnx1": False,
    "@euros3": False,
    "@cpius1": False,
    "@purr3": False,
    "@Pufi3": False,
    "@Moch5": False,
}

# ====== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
if os.path.exists(USERNAMES_FILE):
    with open(USERNAMES_FILE, "r") as f:
        usernames = json.load(f)
else:
    usernames = default_usernames.copy()

if os.path.exists(SALES_LOG_FILE):
    with open(SALES_LOG_FILE, "r") as f:
        sales_log = json.load(f)
else:
    sales_log = []

def save_usernames():
    with open(USERNAMES_FILE, "w") as f:
        json.dump(usernames, f)

def save_sales_log():
    with open(SALES_LOG_FILE, "w") as f:
        json.dump(sales_log, f, indent=2)

# ====== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø±Ø§ÙˆØªØ± ======
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()

# ====== ØªØ®Ø²ÙŠÙ† Ù„ØºØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹ ======
user_languages = {}

# ====== Ù†ØµÙˆØµ Ø¨Ø§Ù„Ù„ØºØªÙŠÙ† ======
texts = {
    "en": {
        "welcome": "ğŸ‘‹ Welcome! You can purchase available usernames from the seller using this bot.",
        "choose_lang": "ğŸ‘‹ Please choose your language or continue:",
        "commission": "ğŸ’° The seller's price is: <b>30 TON</b> per username.\nPlease make sure to pay before confirming.",
        "available_usernames": "ğŸ§¾ Available usernames:",
        "already_sold": "âŒ Sorry, this username has already been sold.",
        "select_username": "ğŸ’¼ You selected <b>{username}</b>\n\nPlease send <b>30 TON</b> to the seller's wallet:\n<code>{wallet}</code>\n\nAfter sending the payment, click <b>'I have paid'</b> to notify the seller.",
        "confirm_payment": "âœ… Payment confirmed. The seller has been notified.",
        "cancelled": "âŒ You have canceled the request for {username}.",
        "add_usage": "â— Usage: /add @username",
        "remove_usage": "â— Usage: /remove @username",
        "username_exists": "âš ï¸ Username already exists.",
        "username_added": "âœ… Username {username} added.",
        "username_removed": "ğŸ—‘ï¸ Username {username} removed.",
        "username_not_found": "âš ï¸ Username not found.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    },
    "ar": {
        "welcome": "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ø¹Ø¨Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.",
        "choose_lang": "ğŸ‘‹ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£Ùˆ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
        "commission": "ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù‡Ùˆ: <b>30 TON</b> Ù„ÙƒÙ„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù….\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯.",
        "available_usernames": "ğŸ§¾ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        "already_sold": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… ØªÙ… Ø¨ÙŠØ¹Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„.",
        "select_username": "ğŸ’¼ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª <b>{username}</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ <b>30 TON</b> Ø¥Ù„Ù‰ Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ø§Ø¦Ø¹:\n<code>{wallet}</code>\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ <b>'ØªÙ… Ø§Ù„Ø¯ÙØ¹'</b> Ù„Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "confirm_payment": "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¨Ø§Ø¦Ø¹.",
        "cancelled": "âŒ Ù„Ù‚Ø¯ Ø£Ù„ØºÙŠØª Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ {username}.",
        "add_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /add @username",
        "remove_usage": "â— Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /remove @username",
        "username_exists": "âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹.",
        "username_added": "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_removed": "ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø³Ù… {username}.",
        "username_not_found": "âš ï¸ Ø§Ù„Ø§Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.",
        "language_set_en": "âœ… Language set to English.",
        "language_set_ar": "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.",
    }
}

def get_text(user_id, key, **kwargs):
    lang = user_languages.get(user_id, "en")
    return texts[lang][key].format(**kwargs)

# ====== /start Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ======
@router.message(Command("start"))
async def start_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ğŸ‡ºğŸ‡¸ English", callback_data="set_lang_en"),
            InlineKeyboardButton(text="ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data="set_lang_ar")
        ],
        [InlineKeyboardButton(text="ğŸ›’ Buy Usernames", callback_data="buy_usernames")],
        [InlineKeyboardButton(text="ğŸ“Š Check Commission", callback_data="commission")]
    ])
    await message.answer(get_text(message.from_user.id, "choose_lang"), reply_markup=keyboard)

# ====== ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ======
@router.callback_query(lambda c: c.data == "set_lang_en")
async def set_lang_en(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "en"
    await callback.answer()
    await callback.message.answer(texts["en"]["language_set_en"])

@router.callback_query(lambda c: c.data == "set_lang_ar")
async def set_lang_ar(callback: CallbackQuery):
    user_languages[callback.from_user.id] = "ar"
    await callback.answer()
    await callback.message.answer(texts["ar"]["language_set_ar"])

# ====== Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© ======
@router.callback_query(lambda c: c.data == "commission")
async def commission_handler(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(get_text(callback.from_user.id, "commission"))

# ====== Ø¹Ø±Ø¶ Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª ======
@router.callback_query(lambda c: c.data == "buy_usernames")
async def show_usernames(callback: CallbackQuery):
    await callback.answer()
    buttons = []
    for username, sold in usernames.items():
        label = f"{username} (SOLD)" if sold else username
        status = "âŒ" if sold else "âœ…"
        buttons.append([InlineKeyboardButton(text=f"{label} {status}", callback_data=f"buy_{username}")])
    await callback.message.answer(get_text(callback.from_user.id, "available_usernames"), reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))

# ====== Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆØ²Ø± ======
@router.callback_query(lambda c: c.data.startswith("buy_"))
async def buy_handler(callback: CallbackQuery):
    await callback.a
